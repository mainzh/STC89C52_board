

# 参考资料

[51单片机入门教程_江协科技](https://www.bilibili.com/video/BV1Mb411e7re/?p=1&spm_id_from=pageDriver&vd_source=b6cd6dd41c0769968f58ce886d249f74)

[10天学会51单片机—郭天祥](https://www.bilibili.com/video/BV1Ks411Y7mi/?spm_id_from=333.999.0.0&vd_source=b6cd6dd41c0769968f58ce886d249f74)



# 开发环境配置



## 安装Keil5 C51

官网：[Keil Product Downloads](https://www.keil.com/download/product/) (外网慢不推荐)

1. 解压缩`Keil5 C51.zip` 

2. 双击`c51v954.exe`

   ![image-20240905101645798](image/image-20240905101645798.png) 

3. 点击`Next` 、勾选`I agree...` 、点击`Next` 

4. 选择安装目录`Core:` `D:\_EmbeddedSystemTool\Keil_v5`  [目录路径为英文]、点击`Next` 

   ![image-20240905101803166](image/image-20240905101803166.png) 

5. "Customer Information"随便填、点击`Next` 

   ![image-20240905101924571](image/image-20240905101924571.png) 

6. 取消`Show Release Notes` 、例程，点击`Finish` 

   ![image-20240905102027361](image/image-20240905102027361.png) 

7. 破解：以管理员权限运行keil_v5，`文件-License Management` ，复制`CID`，解压安装目录下`keygen_new2032.zip` (关闭杀毒软件)，运行`keygen_new2032.exe` ，粘贴`CID` 的值，`Target`选择`C51`，点击`Generate`，复制生成的序列码，点击`Exit`，粘贴进`New License ID Code`，点击`Add LIC`，提示"LIC Added Sucessfully"，注册成功，可使用到2032年

   ![image-20240905102342069](image/image-20240905102342069.png) 

* **因版权问题，在公司使用时禁用联网、位置服务**



## 安装stc-isp

官网：[STMCU中文官网](https://www.stmcu.com.cn/)

1. 解压缩`stc-isp.zip`

   ![image-20240905102757364](image/image-20240905102757364.png) 

2. 将`stc-isp`文件复制到目录`D:\_EmbeddedSystemTool\`

3. 若连接USB数据线不能识别，安装驱动程序：将USB数据线连接开发板，`设备管理器-其他设备-(黄色感叹号：USB2.0-Serial)` ，在`stc-isp\USB to UART Driver`打开`CH340_CH341`，双击`ch341ser.exe-安装`，`驱动安装成功！` ，会有`C:\WCH.CN\CH341SER` ，`设备管理器-端口(COM 和 LPT)-USB-SERIAL CH340(COMx)` 

   > 提示`驱动预安装成功`，一般是开发板未连接电脑



# 硬件

淘宝：普中 51单片机开发板A2套件1  <picakinq旗舰店>

订单号4003241906851083411



资料下载

[资料下载_江协科技](https://jiangxiekeji.com/download.html)

链接：https://pan.baidu.com/s/1_73ooP0BAgrMuFZbw4UQjg?pwd=cog2     提取码：cog2 



# 新建工程



## 新建工程文件夹目录

## \MDK-ARM

Project.uvprojx ——Keil工程启动文件

## \User

用户文件

main.c ——工程主程序文件

readme.txt——工程说明文件

### \\\Hardware

片外模块的模块化函数库

### \\\System

片上模块的模块化函数库

## \keilkill.bat

清除编译生成的中间文件，减小工程文件大小，便于发布工程文件



## 新建工程框架

1. 打开`Keil uVisin5`，`Project——New uVision Project——总目录——项目目录(可以是中文表示项目是干什么的)——MDK-ARM文件夹(工程启动文件夹)——新建Project.uvprojx文件`，保存

2. 在`Select Device...`选择`Legacy Device Database [no RTE]`，[学习的芯片为STC89C52(国产)]选择`AT89C52` 
   在Microchip下找，或者直接搜索

   ![image-20240905131610390](image/image-20240905131610390.png) 

3. `Copy 'STARTUP.A51` 建启动文件，不需要更改，选否

   ![image-20240905131806097](image/image-20240905131806097.png) 

4. 在Manage Project Items（红绿白品图标）中
   将Project Targets下的Target 1 重命名为Template
   在Groups下建立工程框架，User\\Hardware、User\\System、User，点OK
   在Project树下，右键User，选择`Add New Item to Group 'Source Group 1'` ，选择`C File (.C)` ，Name: main，Location：选择项目文件夹中的User文件夹



## 魔术棒设置

在`Options for Target...`

在Output下勾选`Create HEX File-ok`

在C51下，Include Paths下，设置 头文件地址：..\User\Hardware、..\User\System、..\User，点OK



## 编辑程序并编译

1. 编辑`main()`函数
   编辑main函数

   ```c
   void main() {
   }
   ```

   （在main.c文件中第一行右键，选择 Insert '#include <REGX52.H>'，包含51单片机的头文件）

   

2. Translate——编译、 **Build——建立(常用)**、 Rebuild——建立所有工程、 **Download——下载(常用)**
   点击`Build 建立`  工程，`Build Output`显示`0 Error(s), 0 Warning(s)`，说明工程框架没有问题，可以开始正常的开发51单片机

   ![image-20240905140931296](image/image-20240905140931296.png) 



## 下载到单片机

   使用数据线将51单片机连接至电脑，打开 stc-isp软件，单片机型号选择`STC89C52RC`，串口号可以自动搜索，打开程序文件，选择`项目目录\Objects\Project.hex`， 点击`下载/编程` ，重置51开发板的开关冷启动，开发板开始执行程序

   ![image-20240905140551951](image/image-20240905140551951.png) 



# 产生PWM方法

* 模型结构

  ![image-20240911110247529](image/image-20240911110247529.png) 

* 波形

  ![image-20240911110322362](image/image-20240911110322362.png) 



## 直流电机介绍

* 直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，当电极正接时，电机正转，当电极反接时，电机反转

* 直流电机主要由永磁体（定子）、线圈（转子）和换向器组成

  ![image-20240911101404820](image/image-20240911101404820.png) 

* 除直流电机外，常见的电机还有步进电机、舵机、无刷电机、空心杯电机等



## 电机驱动电路

* 大功率器件直接驱动

  ![image-20240911102148181](image/image-20240911102148181.png) 

* H桥驱动

  ![image-20240911103109884](image/image-20240911103109884.png) 

 

## 利用IO口的翻转延时实现PWM LED呼吸灯

缺点：占用主循环，占用CPU不能干其他事情

```c
#include <REGX52.H>

sbit LED = P2^0;

void Delay(unsigned int t)
{
    while(t --);
}

void main()
{
    unsigned char Time,i;
    while(1)
    {
        for(Time=0;Time<100;Time++) //LED由暗变亮
        {
            for(i=0;i<20;i++) //每个亮度循环20次
            {
                LED = 0;
        		Delay(Time);
        		LED = 1;
        		Delay(100 - Time);
            }
        }
        for(Time=100;Time>0;Time--) //LED由亮变暗
        {
            for(i=0;i<20;i++) //每个亮度循环20次
            {
                LED = 0;
        		Delay(Time);
        		LED = 1;
        		Delay(100 - Time);
            }
        }
    }
}
```



## PWM利用定时器中断实现调速

```c
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Timer0.h"

sbit Motor=P1^0;
unsigned char Counter,Compare;
unsigned char KeyNum,Speed;

void Timer0_Init() //定时器初始化 100us@12MHz
{
	TMOD &= 0xF0; //设置定时器模式
	TMOD |= 0x01; //设置定时器模式
	TL0=0x9c; //设置定时初值
    TH0=0xff; //设置定时初值
	TF0 = 0; //清除TF0标志
	TR0 = 1; //定时器0开始计时
  	ET0 = 1; //T0的溢出中断允许位
  	EA = 1; //CPU总中断允许控制位
  	PT0 = 0; //定时器0中断优先级控制位 默认为0  
}

void main()
{
    Timer0_Init();
    
    while(1)
    {
        KeyNum=Key();
        if(KeyNum==1)
        {
            Speed++;
            Speed%=4;
            if(Speed==0){Compare=0;}
            if(Speed==1){Compare=20;}
            if(Speed==2){Compare=50;}
            if(Speed==3){Compare=100;}
        }
        Nixie(1,Speed);
    }
}

void Timer0_Routine() interrupt 1
{
    TL0=0x9c; //设置定时初值
    TH0=0xff; //设置定时初值
    Counter++;
    Counter%=100; //计数器定时自增，到100清零
    if(Counter<Compare)
    {
        Motor=1;
    }
    else
    {
        Motor=0;
    }
}
```



# 串口通信

## 接口及引脚定义

串口的标准接口：DB9公母头

![image-20240910160308427](image/image-20240910160308427.png) 

多的引脚是用来进行 数据流控制的



## 常见通信接口比较

| **名称** | **引脚定义**         | **通信方式** | **特点**       |
| -------- | -------------------- | ------------ | -------------- |
| UART     | TXD、RXD             | 全双工、异步 | 点对点通信     |
| I²C      | SCL、SDA             | 半双工、同步 | 可挂载多个设备 |
| SPI      | SCLK、MOSI、MISO、CS | 全双工、同步 | 可挂载多个设备 |
| 1-Wire   | DQ                   | 半双工、异步 | 可挂载多个设备 |

此外还有：CAN、USB等



## 51单片机的UART

* STC89C52有1个UART (管脚图中RxD/P3.0、TxD/P3.1)

* STC89C52的UART有四种工作模式：

  模式0：同步移位寄存器

  模式1：8位UART，波特率可变（常用）

  模式2：9位UART，波特率固定

  模式3：9位UART，波特率可变



## 串口模式图

![image-20240910163338637](image/image-20240910163338637.png) 

* SBUF (server and buffer)：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，读出的是接收寄存器



## 串口和中断系统

![image-20240910164449731](image/image-20240910164449731.png) 

这里使用的中断系统图是传统51单片机的图，STC89C52的中断系统图可参考手册



## 串口相关的寄存器

<STC89C52系列单片机器件手册> P234

![image-20240910164731801](image/image-20240910164731801.png) 



## 数据显示模式

在串口助手中

* HEX模式/十六进制模式/二进制模式：以原始数据的形式显示
* 文本模式/字符模式：以原始数据编码后的形式显示



## 波特率计算器生成

![image-20240910170824173](image/image-20240910170824173.png) 

```c
void UartInit(void)		//4800bps@11.0592MHz
{
	PCON |= 0x80;		//使能波特率倍速位SMOD
	SCON = 0x50;		//8位数据,可变波特率
	//AUXR &= 0xBF;		//定时器1时钟为Fosc/12,即12T
	//AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xF4;		//设定定时初值
	TH1 = 0xF4;		//设定定时器重装值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
}

```



# 存储器

存储器介绍



![image-20240911150151314](image/image-20240911150151314.png) 

* RAM : Random Access Memory 随机存储器

  存储速度快，掉电丢失数据

  * SRAM

    索存器，用电路存储数据，存储速度最快，容量较少，成本高，应用在CPU高速缓存、变量存储、特殊功能寄存器

  * DRAM

    用电容存储数据，集成度高容值小，漏电现象存电后很快会没电，需加扫描电路，每隔一段时间读取数据再补电，相较SRAM容量更大，成本更低，应用在电脑内存条，手机的运存

* ROM : Read-Only Memory 只读存储器

  存储速度慢，掉电不丢失数据

  * Mask ROM：最早出现，只能读不能写
  * PROM：只能写入1次
  * EPROM：需要用紫外线照射30分钟擦除
  * E2PROM：用电擦除
  * Flash：应用广泛



## 存储器简化模型

![image-20240911164448829](image/image-20240911164448829.png) 





# 什么是单片机

Microcontroller Unit (MCU)

Single-Chip Microcomputer (旧称)

* 内部集成CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能
* 任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机，LED等）的控制
* 单片机跟计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用，同时，学习使用单片机是了解计算机原理与结构的最佳选择



80C51系列单片机是MCS-51系列的典型产品，其他厂商以8051为基核开发的CMOS工艺单片机统称为80C51系列

> Intel：80C31、80C51、87C51、80C32、80C52、87C52
>
> ATMEL：89C51、89C52、89C2051
>
> Philips：华邦、Dallas、STC
>
> Siemens(Infimeon)



# 单片机的应用

使用领域已十分广泛，如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机，就能起到使产品升级换代的功效，常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等



# STC89C52单片机概述

* 所属系列：51单片机系列

* 公司：STC

* 位数：8位

* RAM(随机存储器)：512字节

* ROM(只读存储器)：8K (Flash程序存储)

* 工作频率：12MHz (取决于外部时钟晶振)

* 命名规则：<STC89C52系列单片机器件手册> P19

  STC 89C52RC 40C-PDIP 0721CV4336

  STC厂商、89系列、CMOS工艺、52：2*4K=8K大小ROM(还有51、54、55、58、516)、40：支持晶振最高频率40MHz(运行速度)、C：商业级( I工业级、军用级，支持的温度使用范围不同)、PDIP：封装形式为双列直插式、0721：07年第21周生产、CV4336生产批号

  ![image-20240905115859365](image/image-20240905115859365.png) 

  ![image-20240905112314351](image/image-20240905112314351.png) 

* 内核结构：<STC89C52系列单片机器件手册> P14、15

  ![image-20240905112148542](image/image-20240905112148542.png) 

  ![image-20240905112540396](image/image-20240905112540396.png) 

* 管脚图：<STC89C52系列单片机器件手册> P16

  ![image-20240905113037617](image/image-20240905113037617.png) 

* 最小应用系统：<STC89C52系列单片机器件手册> P20

  必须有：电源电路、时钟电路、(复位电路可选，用来复位程序)



# 开发板原理图

<开发板原理图_普中-2-3-4>



# 电子元器件规格标识

102 =10 00 =1k

471 =47 0 

473 =47 000 =47k



# 51数据类型

参考 C语言 数据类型

与 C语言的区别？？？



# 51数据运算

参考 C语言 运算符



# C51的sfr、sbit

* sfr（special function register）：特殊功能寄存器声明

  例：sfr P0 = 0x80;

  声明P0口寄存器，物理地址为0x80

* sbit（special bit）：特殊位声明

  例：sbit P0_1 = 0x81;  或  sbit P0_1 = P0^1;

  声明P0寄存器的第1位

* 可位寻址/不可位寻址：在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，又因为一个寄存器里有8位，所以位的数量是寄存器数量的8倍，单片机无法对所有位进行编码，故每8个寄存器中，只有一个是可以位寻址的。

  对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&=”、“|=”、“^=”的方法进行位操作

* 






# 单片机基础

C语言基础、数电基础、模电基础，二进制、十进制、十六进制的转换，与、或、非逻辑关系



电平特性：

数字电路中只有两种电平：高、低

> 单片机为TTL电平：高+5V、低0V
>
> 计算机的串口为RS232电平：高-12V、低+12V
>
> 所以计算机与单片机之间通讯需加电平转换芯片max232



# 单片机主要掌握以下几点

最小系统能够运行的必要条件：1. 电源、2. 晶振、 3.复位电路

对单片机任意I/O口的随意操作：1.输出控制电平高低、 2.输入检测电平高低

定时器：掌握最常用的方式2

中断：外部中断、定时器中断、串口中断

串口通信：单片机之间、单片机与计算机之间



![image-20240909170241749](image/image-20240909170241749.png) 





# 定时器介绍

<STC89C52系列单片机器件手册> P187

51单片机的定时器属于单片机的内部资源，其电路的连接和运转均在单片机内部完成



# 定时器的作用

* 用于计时系统，可实现软件计时，或者使程序每隔一固定时间完成一项操作
* 替代长时间的 Delay，提高CPU的运行效率合处理速度
* 。。。



# STC89C52定时器资源

* 定时器个数：3个 (T0、T1、T2) ，T0和T1与传统的51单片机兼容，T2是此型号单片机增加的资源
* 注意：定时器的资源和单片机的型号是关联在一起的，不同的型号可能会有不同的定时器个数和操作方式，但一般来说，T0和T1的操作方式是所有51单片机所共有的



# 定时器框图

定时器在单片机内部就像一个小闹钟一样，根据时钟的输出信号，每隔“一秒”，计数单元的数值就增加一，当计数单元数值增加到“设定的闹钟提醒时间”时 (*这里是计数单元的最大值*)，计数单元就会向中断系统发出中断申请，产生“响铃提醒”，使程序跳转到中断服务函数中执行

![image-20240909150627374](image/image-20240909150627374.png) 



# 定时器工作模式

* STC89C52的T0和T1均有四种工作模式：

  模式0：13位定时器/计数器

  模式1：16位定时器/计数器（常用）

  模式2：8位自动重装模式

  模式3：两个8位计数器

* 工作模式1框图 <STC89C52系列单片机器件手册> P191

  ![image-20240909151159474](image/image-20240909151159474.png) 

   

# 定时器时钟

SYSclk：系统时钟，即晶振周期，本开发板上的晶振为12MHz (定时器)

T0 Pin：T0/P3.4  外部I/O引脚 (计时器)

如果 $C/\overline{T}=0$，使用SYSclk；如果  $C/\overline{T}=1$，使用T0 Pin

经过分频后 (12T、6T 两种模式，默认为12T)，12MHz/12T = 1MHz，一个周期为1us



# 定时器中断系统

<STC89C52系列单片机器件手册> P156

* 中断程序流程

  ![image-20240909155313973](image/image-20240909155313973.png) 

  相当于同时完成两个任务



# STC89C52中断资源

* 中断源个数：8个（外部中断0、定时器0中断、外部中断1、定时器1中断、串口中断、定时器2中断、外部中断2、外部中断3）

* 中断优先级个数：4个

* 中断号

  ![image-20240909155717631](image/image-20240909155717631.png) 

* 注意：中断的资源和单片机的型号是关联在一起的，不同的型号可能会有不同的中断资源，例如中断源个数不同、中断优先级个数不同等等



# 定时器和中断系统

这里使用的中断系统图是传统51单片机的图，STC89C52的中断系统图可参考手册 <STC89C52系列单片机器件手册> P158

![image-20240909160142481](image/image-20240909160142481.png) 



# 定时器相关寄存器

* 寄存器是连接软硬件的媒介

* 在单片机中寄存器就是一段特殊的RAM存储器，一方面，寄存器可以存储和读取数据，另一方面，每一个寄存器背后都连接了一根导线，控制着电路的连接方式

* 寄存器相当于一个复杂机器的“操作按钮”

  STC89C52的中断系统图可参考手册 <STC89C52系列单片机器件手册> P187

![image-20240909160721194](image/image-20240909160721194.png) 

STC89C52的中断系统图可参考手册 <STC89C52系列单片机器件手册> P160

![image-20240909160639862](image/image-20240909160639862.png) 



## 定时器计算器生成

![image-20240909221804376](image/image-20240909221804376.png) 

```c
void Timer0Init(void)		//1毫秒@11.0592MHz
{
	//AUXR &= 0x7F;		//定时器时钟12T模式  (89C52没有配置该模式的地方，需取消,默认为12T模式)
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x66;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
  //中断寄存器配置
  ET0 = 1; //T0的溢出中断允许位
  EA = 1; //CPU总中断允许控制位
  PT0 = 0; //定时器0中断优先级控制位 默认为0
}
```



# 软件延时计算器生成

![image-20240910094858834](image/image-20240910094858834.png) 

```c
void Delay1ms()		//@11.0592MHz
{
	unsigned char i, j;

	_nop_();
	i = 2;
	j = 199;
	do
	{
		while (--j);
	} while (--i);
}

```

